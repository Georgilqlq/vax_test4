<!DOCTYPE html>

<html>

<head>
    <title>cube texture
    </title>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script src="three.min.js"></script>
    <script src="stats.min.js"></script>
    <script src="WebGL.js"></script>
    <script src="vax.js"></script>
</head>

<body>
    <script>
        vaxInit();


        const refractionCube = new THREE.CubeTextureLoader().load([
            'images/posx.jpg', 'images/negx.jpg',
            'images/posy.jpg', 'images/negy.jpg',
            'images/posz.jpg', 'images/negz.jpg']);
        refractionCube.mapping = THREE.CubeRefractionMapping;



        camera.fov = 30;
        onWindowResize();
        scene.background = new THREE.CubeTextureLoader().load([
            'images/posx.jpg', 'images/negx.jpg',
            'images/posy.jpg', 'images/negy.jpg',
            'images/posz.jpg', 'images/negz.jpg']);
            
        // camera.position.set(0, 0, 0);
        // camera.lookAt(new THREE.Vector3(0, 0, 0));

        var material = new THREE.MeshLambertMaterial({ color: 0xffffff, envMap: refractionCube, combine: THREE.MixOperation, reflectivity: 0.8 });
        var geometry = new THREE.IcosahedronGeometry(5);


        for (var i = 0; i < 20; i++) {
            var icosahedron = new THREE.Mesh(geometry, material);
            icosahedron.position.set(THREE.Math.randFloat(-100, 100), THREE.Math.randFloat(-100, 100), THREE.Math.randFloat(-100, 100));
            scene.add(icosahedron);
        }

        window.addEventListener("deviceorientation", handleOrientation, true);
        var alpha_prev, beta_prev, gamma_prev;
        var flipped = false;
        function handleOrientation(event) {
            var absolute = event.absolute;
            var alpha = event.alpha;
            var beta = event.beta;
            var gamma;
            if (event.gamma < 0 && event.gamma > -90) {
                gamma = event.gamma + 90;
                scene.rotation.y = -alpha * Math.PI / 180;
                scene.rotation.x = gamma * Math.PI / 180;
            }
            else {
                gamma = event.gamma - 90;
                scene.rotation.y = (-alpha * Math.PI / 180) - Math.PI;
                scene.rotation.x = gamma * Math.PI / 180;
            }
        }



        // scene.remove(light);
        // var light = new THREE.PointLight(0xffffff, 1, 100);
        // light.position.set(0, 0, 0);
        // light.castShadow = true; // default false
        // scene.add(light);

        function animate() {

        }
    </script>
</body>

</html>